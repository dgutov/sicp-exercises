(define (not-null? x)
  (not (null? x)))

;; Ex. 3.14
(define (reverse! x) ; reverses the list in place
  (define (loop x y)
    (if (null? x)
        y
        (let ((temp (cdr x)))
          (set-cdr! x y)
          (loop temp x))))
  (loop x '()))

;; Ex. 3.18
(define (contains-cons? ys y)
    (cond ((null? ys) #f)
          ((eq? y ys) #t)
          ((null? (cdr ys)) #f)
          (else (contains-cons? (cdr ys) y))))

(define (cycles? xs)
  (define (cycles?- xs ys start)
    (cond ((null? xs) #f)
          ((eq? start xs) #t)
          ((contains-cons? ys xs) #t)
          (else (cycles?- (cdr xs)
                          (cons xs ys)
                          start))))
  (if (null? xs)
      #f
      (cycles?- (cdr xs) '() xs)))

;; Ex. 3.19
;; constant-space version of `cycles?'
(define (cycles-cs? xs)
  (define (restore! xs ys)
    (reverse! ys)
    (set-cdr! ys xs))
  (define (cycles?- xs ys)
    (cond ((null? xs)
           (restore! xs ys)
           #f)
          ((contains-cons? ys xs)
           (restore! xs ys)
           #t)
          (else
           (let ((tail (cdr xs)))
             (set-cdr! xs ys)
             (cycles?- tail xs)))))
  (cycles?- xs '()))

;; Ex. 3.21
(define (print-queue q)
  (display (car q))
  (newline))

;; Ex. 3.23
(define (make-deque)
  (let ((front-ptr '())
        (rear-ptr '()))
    (define (empty-deque?)
      (null? front-ptr))
    (define (traverse ptr next)
      (if (null? ptr) '()
          (cons (car ptr)
                (traverse (next ptr) next))))
    (define (front-deque)
      (traverse front-ptr caddr))
    (define (rear-deque)
      (traverse rear-ptr cadr))
    (define (make-deque-cell x prev next)
      (list x prev next))
    (define (set-cell-prev! cell x)
      (set-car! (cdr cell) x))
    (define (set-cell-next! cell x)
      (set-car! (cddr cell) x))
    (define (front-insert-deque! x)
      (let ((cell (make-deque-cell x '() front-ptr)))
        (if (null? front-ptr)
            (set! rear-ptr cell)
            (set-cell-prev! front-ptr cell))
        (set! front-ptr cell)))
    (define (rear-insert-deque! x)
      (let ((cell (make-deque-cell x rear-ptr '())))
        (if (null? front-ptr)
            (set! front-ptr cell)
            (set-cell-next! rear-ptr cell))
        (set! rear-ptr cell)))
    (define (front-delete-deque!)
      (if (not-null? front-ptr)
          (let ((next (caddr front-ptr)))
            (if (not-null? next)
                (set-cell-prev! next '())
                (set! rear-ptr '()))
            (set! front-ptr next))
          (error "Deque is empty")))
    (define (rear-delete-deque!)
      (if (not-null? rear-ptr)
          (let ((prev (cadr rear-ptr)))
            (if (not-null? prev)
                (set-cell-next! prev '())
                (set! front-ptr '()))
            (set! rear-ptr prev))
          (error "Deque is empty")))
    (define (dispatch m)
      (cond ((eq? m 'empty-deque?) empty-deque?)
            ((eq? m 'front-deque) front-deque)
            ((eq? m 'rear-deque) rear-deque)
            ((eq? m 'front-insert-deque!) front-insert-deque!)
            ((eq? m 'rear-insert-deque!) rear-insert-deque!)
            ((eq? m 'front-delete-deque!) front-delete-deque!)
            ((eq? m 'rear-delete-deque!) rear-delete-deque!)
            (else (error "Undefined operation on deque" m))))
    dispatch))

;; Ex. 3.25
;; Caveat: breaks when a new keychain contains an old one.
;; Example: ((t 'insert!) 'a 1 2)
;;          ((t 'lookup) 1 2 3) -> error: 'a is not an alist
(define (make-table)
  (let ((local-table (list '*table*)))
    (define (lookup- table keys)
      (let* ((key (car keys))
             (subtable (assoc key (cdr table)))
             (rest-keys (cdr keys)))
        (if subtable
            (let ((rest-keys (cdr keys)))
              (if (null? rest-keys)
                  (cons 'ok subtable)
                  (lookup- subtable rest-keys)))
            (cons keys table))))
    (define (lookup . keys)
      (let ((res (lookup- local-table keys)))
        (if (eq? (car res) 'ok)
            (cddr res)
            #f)))
    (define (insert!- keys table)
      (if (null? keys)
          table
          (let ((subtable (cons (car keys) '())))
            (set-cdr! table (cons subtable (cdr table)))
            (insert!- (cdr keys) subtable))))
    (define (insert! value . keys)
      (let* ((res (lookup- local-table keys))
             (table (cdr res))
             (rest-keys (car res)))
        (if (not (eq? rest-keys 'ok))
            (set! table (insert!- rest-keys table)))
        (set-cdr! table value)))
    (define (dispatch m)
      (cond ((eq? m 'lookup) lookup)
            ((eq? m 'insert!) insert!)
            (else (error "Unknown operation" m))))
    dispatch))

;; Ex. 3.29
;; delay = 2 * inverter-delay + and-gate-delay
(define (or-gate a1 a2 output)
  (let ((b1 (make-wire))
        (b2 (make-wire))
        (c (make-wire)))
    (inverter a1 b1)
    (inverter a2 b2)
    (and-gate b1 b2 c)
    (inverter c output)
    'ok))

;; Ex. 3.30
;; ripple-carry-adder-delay = n * (full-adder-delay-for-wire-c)
;; delay-for-wire-c = max(or-gate-delay, and-gate-delay + inverter-delay)       
;;                    + 2 * and-gate-delay + or-gate-delay
(define (ripple-carry-adder as bs ss c-in)
  (if (not-null? as)
      (let ((c-out (make-wire))
            (a (car as))
            (b (car bs))
            (s (car ss)))
        (full-adder a b c-in s c-out)
        (ripple-carry-adder (cdr as) (cdr bs)
                            (cdr ss) c-out))))

;; Ex. 3.33
(define (averager a b c)
  (let ((e (make-connector))
        (t (make-connector)))
    (constant 2 t)
    (multiplier c t e)
    (adder a b e)
    'ok))

;; Ex. 3.35
(define (squarer a b)
  (define (process-new-value)
    (if (has-value? b)
        (if (< (get-value b) 0)
            (error "Square less than 0 -- SQUARER" (get-value b))
            (set-value! a (sqrt b) me))
        (if (has-value? a)
            (set-value! b (* a a) me))))
  (define (process-forget-value)
    (forget-value! a me)
    (forget-value! b me)
    (process-new-value))
  (define (me request)
    (cond ((eq? request 'I-have-a-value)  
           (process-new-value))
          ((eq? request 'I-lost-my-value) 
           (process-forget-value))
          (else 
           (error "Unknown request -- SQUARER" request))))
  (connect a me)
  (connect b me)
  me)

;; Ex. 3.37
(define (c- x y)
  (let ((minus (make-connector))
        (u (make-connector))
        (z (make-connector)))
    (constant -1 minus)
    (multiplier y minus u)
    (adder x u z)
    z))

(define (c* x y)
  (let ((z (make-connector)))
    (multiplier x y z)
    z))

(define (c/ x y)
  (let ((z (make-connector)))
    (multiplier z y x)
    z))

(define (cv a)
  (let ((z (make-connector)))
    (constant a z)
    z))
